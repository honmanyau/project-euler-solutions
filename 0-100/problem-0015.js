/**************/
/* Problem 14 */
/**************/

// Brute-force, takes too long to calculate for size = 20
// Approximately 15–18 ms for n = 10;
function generatePaths(gridX = 20, gridY = gridX, x = 0, y = 0) {
  const validMove = x <= gridX && y <= gridY;
  const end = x === gridX && y === gridY;

  if (end) {
    return 1;
  }

  if (!validMove) {
    return 0;
  }

  return(
    generatePaths(gridX, gridY, x, y + 1) +
    generatePaths(gridX, gridY, x + 1, y)
  );
};

// Brute force with symmetry considered
// Approximately 8–10 ms for n = 10;
function generatePathsSym(gridX = 20, gridY = gridX, x = 0, y = 0) {
  const validMove = x <= gridX && y <= gridY;
  const end = x === gridX && y === gridY;

  if (end) {
    return 2;
  }

  if (!validMove) {
    return 0;
  }

  if (x !== 0 || y !== 0) {
    return(
      generatePathsSym(gridX, gridY, x, y + 1) +
      generatePathsSym(gridX, gridY, x + 1, y)
    );
  }
  else {
    return generatePathsSym(gridX, gridY, x + 1, y);
  }
};

// The probably can be solved pseudo numerically by noting that the total
// distance moved to either the right or down is limited by the size of the
// grid. For example, if dx represents the distance of a single move to the
// right, then SIGMA(dx) = l, where l is the horizontal size of the grid
// To illustrate this using a grid of size 2x2, the possible moves to **only**
// the right, setA, are:
//
// [2]
// [1, 1]
//
//
// Similar, and since the grid is a square, the possible moves to **only**
// downward, setB, are:
//
// [2]
// [1, 1]
//
//
// A complete path can be described by combining an array from each set
// and interleavingly combining the elements. For example:
//
// [2] + [2] describes the path (0, 0) -> (0, 2) -> (2, 2)
// [1, 1] + [2] describes the path (0, 0) -> (1, 0) -> (1, 2) -> (2, 2)
// [1, 1] + [1, 1] describes the path
// (0, 0) -> (1, 0) -> (1, 1) -> (2, 1) -> (2, 2)
//
//
// The remaining paths can be generated by switching the order of setA and setB
// as all paths are mirrored in a square grid. Therefore there are 3 x 2 =  6
// valid paths in a 2 x 2 grid.
//
// It should be noted that the array taken from the first array, assuming
// that the first move is produced from it, **must** have exactly 0 or 1 array
// more than the second array. To illustrate this, consider the case of
// [2] + [1, 1]:
//
// First move: (0, 0) -> (2, 0)
// Second move: (2, 0) -> (2, 1)
// Final move: (2, 1) -> (2, 2)
//
//
// From the example above, it is clear that the second and third moves combined
// is equivalient to a single move described by [2] in setB, simply because,
// by definition, the requirement of interleavingly combining the elements
// cannot be met.

function seed(n) {
  return Array.from(Array(n)).map(() => 1);
}

// Brute force with symmetry and the above considered
// Approximately 8–10 ms for n = 10;
// Algorithm doesn't scale as well as generatePathsSym :/
function generatePathsSymSum(gridX = 20, gridY = gridX, x = 0, y = 0, d = 'x') {
  const end = x === gridX && y === gridY;

  if (end) {
    return 2;
  }

  const moveRight = d === 'x';
  let paths = 0;

  if (moveRight) {
    if (x !== gridX) {
      for (let dx = x + 1; dx <= gridX; dx++) {
        paths += generatePathsSymSum(gridX, gridY, dx, y, 'y');
      }
    }
  }
  else {
    if (y !== gridY) {
      for (let dy = gridY; dy >= gridY - (gridX - x); dy--) {
        paths += generatePathsSymSum(gridX, gridY, x, dy, 'x');
      }
    }
  }

  return paths;
};

// Serendipitous discovery by drawing paths on grids—for any given grid of size
// n, the number of paths, depending on the first move dx to the right, the
// number of paths, p, can be described as follows:
//
// let n = 3;
//
// dx = 3, p = 1;
// dx = 2, p = 3;
// dx = 1, p = 6 = 3 + 3;
//
//
// let n = 4;
//
// dx = 4, p = 1;
// dx = 3, p = 4;
// dx = 2, p = 10 = 4 + 6;
// dx = 1, p = 20 = 4 + 6 + 6 + 4;
//
//
// Thinking that it looks like numbers in the pascal triangle:
//
// 1
// 1 1
// 1 2 1
// 1 3 3 1
// 1 4 6 4 1
// 1 5 10 10 5 1
// 1 6 15 20 15 6 1
// 1 7 21 35 35 21 7 1
//
// And it turns out to be the diagonals of the pascal triangle! This observation
// was corroboarted using the function getPartialPath().
//
// If the first number of the pascal triangle is denotes as (0, 0), the result
// for:
//
// n = 2, which is 6, is found in (4, 3)
// n = 3, which is 20, is found in (6, 4)
// n = 4, which is 70, is found in (8, 5);
//
//
// Which can be generalised to (2n, n)
//
// The formula for calculating the number at a given row and column of the
// pascal triangle is r! / r!(r - c)!, where r and c are the index corresponding
// to the row and column of the number, respectively. Substituting the
// expression (2n, n) for the desired number:
//
// Number of paths = (2n)! / n!(2n - n)! = (2n)! / (n!)^2
//
// To double check:
//
// let n = 2
//
// paths = (2 x 2)! / (2!)^2 = 4! / 4 = 3! = 6;
// paths = (2 x 3)! / (3!)^2 = 6! / 3!3! = 5! / 3! = 5 * 4 = 20;

function getPartialPath(size, lim, x = 0, y = 0) {
  const validMove = x <= size && y <= size;
  const end = x === size && y === size;

  if (end) {
    return 1;
  }

  if (!validMove) {
    return 0;
  }

  if (x !== 0 || y !== 0) {
    return(
      getPartialPath(size, size, x, y + 1) +
      getPartialPath(size, size, x + 1, y)
    );
  }
  else {
    let paths = getPartialPath(size, size, lim, y);

    if (lim < size) {
      paths -= getPartialPath(size, size, lim + 1, y);
    }

    return paths;
  }
};

function factorial(n) {
  if (n === 1) {
    return 1;
  }

  return n * factorial(n - 1);
}

function latticePaths(n) {
  return factorial(2 * n) / factorial(n) ** 2;
}

const init = process.hrtime();
console.log(`Solution: ${latticePaths(20)}.`);
const final = process.hrtime(init);
console.log(`Time taken: ${final[0] * 1000 + final[1] / 1000000} ms.`);

module.exports = {
  generatePaths,
  generatePathsSym,
  generatePathsSymSum,
  getPartialPath,
  factorial,
  latticePaths
};
